<!-- 
  複数オブジェクトの描画手順
  １．複数オブジェクトのバッファ情報を1回のループで処理するためにsetupBufferとupdateUniformsを統合する。
  ２．オブジェクトごとにバッファ、バインドグループを作成し、それを配列buffersに格納する。
  ３．配列buffersを使って複数のオブジェクトを描画する。
  ４．更新したuniformデータを使ってオブジェクトごとにバインドグループを更新し、再描画する。

  リサイズ処理は、各オブジェクトのユニフォームバッファにプロジェクションマトリックスを再設定する必要がある。
 -->

<html>
  <head>
    <title>Real-Time 3D Graphics with WebGPU</title>
    <link rel="stylesheet" href="../../common/lib/normalize.css" />
    <script type="text/javascript" src="../../common/js/utils.js"></script>
    <script type="text/javascript" src="../../common/lib/dat.gui.js"></script>
    <script type="module">
      ("use strict");
      import {
        vec3,
        mat4,
      } from "https://wgpu-matrix.org/dist/1.x/wgpu-matrix.module.js";

      const FLOAT_SIZE = 4,
        MAT4_SIZE = 16 * FLOAT_SIZE,
        VEC3_SIZE = 3 * FLOAT_SIZE,
        VEC3_PADDING = 4,
        degToRad = (d) => (d * Math.PI) / 180;

      let canvas,
        device,
        context,
        canvasFormat,
        objects = [],
        buffers = [],
        cellPipeline,
        depthTextureView,
        lightPosition = vec3.fromValues(4.5, 3, 15),
        lightDiffuse = vec3.fromValues(1, 1, 1),
        lightAmbient = vec3.fromValues(1, 1, 1),
        lightSpecular = vec3.fromValues(1, 1, 1),
        shininess = 200.0,
        clearColor = [0.8, 0.8, 0.8, 1.0],
        angle = 0,
        lastTime = 0,
        distance = -100;

      async function init() {
        canvas = setupCanvas();
        await setupWebGPU(canvas);
        await setupShadersAndPipeline();
        await loadObjects();
        setupBuffers();
        render();
        initControls();
      }

      function setupCanvas() {
        canvas = utils.getCanvas("webgpu-canvas");
        autoResizeCanvas(canvas);
        return canvas;
      }

      async function setupWebGPU(canvas) {
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        device = await adapter.requestDevice();
        context = utils.getGPUContext(canvas);
        canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: canvasFormat,
        });
      }

      async function setupShadersAndPipeline() {
        const vertexShaderModule = device.createShaderModule({
          code: await fetch("./vertexShader.wgsl").then((res) => res.text()),
        });

        const fragmentShaderModule = device.createShaderModule({
          code: await fetch("./fragmentShader.wgsl").then((res) => res.text()),
        });

        const vertexBufferLayout = {
          arrayStride: 6 * Float32Array.BYTES_PER_ELEMENT, // 位置xyz + 法線xyz + オブジェクトID * float32は4バイト
          attributes: [
            // position
            {
              format: "float32x3",
              offset: 0,
              shaderLocation: 0,
            },
            // normal
            {
              format: "float32x3",
              offset: 3 * Float32Array.BYTES_PER_ELEMENT,
              shaderLocation: 1,
            },
          ],
        };

        const uniformBindGroupLayout = device.createBindGroupLayout({
          entries: [
            {
              binding: 0,
              visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT, // @vertex,@fragment両方でuniformを使用できるようにする
              buffer: {
                type: "uniform",
              },
            },
          ],
        });

        cellPipeline = device.createRenderPipeline({
          label: "Cell pipeline",
          layout: device.createPipelineLayout({
            bindGroupLayouts: [uniformBindGroupLayout],
          }),
          vertex: {
            module: vertexShaderModule,
            entryPoint: "vertexMain",
            buffers: [vertexBufferLayout],
          },
          fragment: {
            module: fragmentShaderModule,
            entryPoint: "fragmentMain",
            targets: [{ format: canvasFormat }],
          },
          primitive: {
            topology: "triangle-list",
            cullMode: "none", // ポリゴンの裏も表も描画する
          },
          depthStencil: {
            format: "depth24plus",
            depthWriteEnabled: true,
            depthCompare: "less-equal", // WebGL2のgl.LEQUALと同等の設定
          },
        });
      }

      async function loadObjects() {
        const objectPromises = [
          loadObject("../../common/models/geometries/plane.json", "plane"),
          loadObject("../../common/models/geometries/cone2.json", "cone"),
          loadObject("../../common/models/geometries/sphere1.json", "sphere"),
          loadObject("../../common/models/geometries/sphere3.json", "light"),
        ];

        await Promise.all(objectPromises)
          .then(() => {
            console.log("All objects loaded:", objects);
          })
          .catch((error) => {
            console.error("Error loading objects:", error);
          });
      }

      function loadObject(filePath, alias) {
        return fetch(filePath)
          .then((res) => res.json())
          .then((data) => {
            data.alias = alias;
            objects.push(data);
          });
      }

      function setupBuffers() {
        const fov = degToRad(45);
        const aspect = canvas.width / canvas.height;
        const near = 0.1;
        const far = 1000;
        const projectionMatrix = mat4.perspective(fov, aspect, near, far);

        // 3つのmat4、2つのfloat32 + パディング、7つのvec3 + パディング
        const SUM_MAT4_SIZE = 3 * MAT4_SIZE;
        const SUM_FLOAT_SIZE = 2 * FLOAT_SIZE + 8;
        const SUM_VEC3_SIZE = 7 * (VEC3_SIZE + VEC3_PADDING);

        const alignedSize = SUM_MAT4_SIZE + SUM_FLOAT_SIZE + SUM_VEC3_SIZE;

        objects.forEach((object, i) => {
          // 複数オブジェクトのユニフォームバッファを作成
          const modelViewMatrix = mat4.identity();
          mat4.translate(modelViewMatrix, [0, 0, distance], modelViewMatrix);
          mat4.rotateX(modelViewMatrix, degToRad(30), modelViewMatrix);

          if (object.alias === "light") {
            mat4.translate(modelViewMatrix, lightPosition, modelViewMatrix);
          }

          const normalMatrix = mat4.inverse(modelViewMatrix);
          mat4.transpose(normalMatrix, normalMatrix);

          const uniformData = new Float32Array(alignedSize / FLOAT_SIZE);
          let offset = 0;

          uniformData.set(projectionMatrix, offset);
          offset += MAT4_SIZE / FLOAT_SIZE;

          uniformData.set(modelViewMatrix, offset);
          offset += MAT4_SIZE / FLOAT_SIZE;

          uniformData.set(normalMatrix, offset);
          offset += MAT4_SIZE / FLOAT_SIZE;

          uniformData[offset] = shininess;
          offset += 1;

          uniformData[offset] = distance;
          offset += 1;
          offset += 2; // 次のvec3型のアライメントを満たすためのパディング

          uniformData.set(lightPosition, offset);
          offset += (VEC3_SIZE + VEC3_PADDING) / FLOAT_SIZE;

          uniformData.set(object.diffuse, offset);
          offset += (VEC3_SIZE + VEC3_PADDING) / FLOAT_SIZE;

          uniformData.set(object.ambient, offset);
          offset += (VEC3_SIZE + VEC3_PADDING) / FLOAT_SIZE;

          uniformData.set(object.specular, offset);
          offset += (VEC3_SIZE + VEC3_PADDING) / FLOAT_SIZE;

          uniformData.set(lightDiffuse, offset);
          offset += (VEC3_SIZE + VEC3_PADDING) / FLOAT_SIZE;

          uniformData.set(lightAmbient, offset);
          offset += (VEC3_SIZE + VEC3_PADDING) / FLOAT_SIZE;

          uniformData.set(lightSpecular, offset);

          const uniformBuffer = device.createBuffer({
            size: uniformData.byteLength,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(uniformBuffer, 0, uniformData);

          const uniformBindGroup = device.createBindGroup({
            label: "Uniform Bind Group",
            layout: cellPipeline.getBindGroupLayout(0),
            entries: [
              {
                binding: 0,
                resource: {
                  buffer: uniformBuffer,
                  size: uniformData.byteLength,
                },
              },
            ],
          });

          // 複数オブジェクトの頂点バッファとインデックスバッファを作成
          let vertices = object.vertices;
          const indices = new Uint16Array(object.indices);
          const normals = utils.createNormals(vertices, indices);
          const vertexData = []; // 1つのオブジェクトの頂点、法線、オブジェクトIDを格納する

          for (let i = 0; i < vertices.length; i += 3) {
            vertexData.push(vertices[i], vertices[i + 1], vertices[i + 2]); // position
            vertexData.push(normals[i], normals[i + 1], normals[i + 2]); // normal
          }
          const vertexDataFloat32Array = new Float32Array(vertexData);

          const vertexBuffer = device.createBuffer({
            label: "Vertex With Normals Buffer",
            size: vertexDataFloat32Array.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(vertexBuffer, 0, vertexDataFloat32Array);

          const indexBuffer = device.createBuffer({
            label: "Index Buffer",
            size: indices.byteLength,
            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
          });
          device.queue.writeBuffer(indexBuffer, 0, indices);

          // 描画に必要な情報をbuffersに格納
          buffers.push({
            vertexBuffer: vertexBuffer,
            indexBuffer: indexBuffer,
            indexLength: indices.length,
            uniformBindGroup: uniformBindGroup,
            uniformBuffer: uniformBuffer, // uniformBuffer更新時のみ使用
            bindGroupSize: uniformData.byteLength, // uniformBuffer更新時のみ使用
          });
        });

        const depthTexture = device.createTexture({
          size: [canvas.width, canvas.height, 1],
          format: "depth24plus",
          usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
        depthTextureView = depthTexture.createView();
      }

      function updateUniforms(angle) {
        // 2つのmat4、2つのfloat32 + パディング、2つのvec3 + パディング
        const SUM_MAT4_SIZE = 2 * MAT4_SIZE;
        const SUM_FLOAT_SIZE = 2 * FLOAT_SIZE + 8;
        const SUM_VEC3_SIZE = 2 * (VEC3_SIZE + VEC3_PADDING);

        const alignedSize = SUM_MAT4_SIZE + SUM_FLOAT_SIZE + SUM_VEC3_SIZE;

        objects.forEach((object, i) => {
          const modelViewMatrix = mat4.identity();
          mat4.translate(modelViewMatrix, [0, 0, distance], modelViewMatrix);
          mat4.rotateX(modelViewMatrix, degToRad(30), modelViewMatrix);
          mat4.rotateY(modelViewMatrix, angle, modelViewMatrix);

          if (object.alias === "light") {
            mat4.translate(modelViewMatrix, lightPosition, modelViewMatrix);
          }

          const normalMatrix = mat4.inverse(modelViewMatrix);
          mat4.transpose(normalMatrix, normalMatrix);

          const uniformData = new Float32Array(alignedSize / FLOAT_SIZE);
          let offset = 0;

          uniformData.set(modelViewMatrix, offset);
          offset += MAT4_SIZE / FLOAT_SIZE;

          uniformData.set(normalMatrix, offset);
          offset += MAT4_SIZE / FLOAT_SIZE;

          uniformData[offset] = shininess;
          offset += 1;

          uniformData[offset] = distance;
          offset += 1;
          offset += 2; // 次のvec3型のアライメントを満たすためのパディング

          uniformData.set(lightPosition, offset);
          offset += (VEC3_SIZE + VEC3_PADDING) / FLOAT_SIZE;

          uniformData.set(object.diffuse, offset);

          const uniformBuffer = buffers[i].uniformBuffer;
          const bindGroupSize = buffers[i].bindGroupSize;
          device.queue.writeBuffer(
            uniformBuffer,
            MAT4_SIZE,
            uniformData.buffer,
            uniformData.byteOffset,
            alignedSize
          );

          const uniformBindGroup = device.createBindGroup({
            label: "Update Uniform Bind Group",
            layout: cellPipeline.getBindGroupLayout(0),
            entries: [
              {
                binding: 0,
                resource: {
                  buffer: uniformBuffer,
                  size: bindGroupSize, // 更新用のサイズではなく、bindGroup生成時のサイズを指定する必要がある
                },
              },
            ],
          });

          buffers[i].uniformBindGroup = uniformBindGroup;
        });
      }

      async function draw() {
        const commandEncoder = device.createCommandEncoder();
        const pass = commandEncoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: [...clearColor],
              storeOp: "store",
            },
          ],
          depthStencilAttachment: {
            view: depthTextureView,
            depthClearValue: 1.0,
            depthLoadOp: "clear",
            depthStoreOp: "store",
          },
        });
        pass.setPipeline(cellPipeline);

        // 複数のオブジェクトを描画する
        for (const {
          vertexBuffer,
          indexBuffer,
          indexLength,
          uniformBindGroup,
        } of buffers) {
          pass.setBindGroup(0, uniformBindGroup);
          pass.setVertexBuffer(0, vertexBuffer);
          pass.setIndexBuffer(indexBuffer, "uint16");
          pass.drawIndexed(indexLength, objects.length); // 第一引数: インデックス数、第二引数: インスタンス数
        }

        pass.end();
        device.queue.submit([commandEncoder.finish()]);
      }

      function animate() {
        const timeNow = new Date().getTime();
        if (lastTime) {
          const elapsed = timeNow - lastTime;
          angle += (90 * elapsed) / 1000000.0;

          updateUniforms(angle);
        }
        lastTime = timeNow;
      }

      function render() {
        requestAnimationFrame(render);
        draw();
        animate();
      }

      function autoResizeCanvas(canvas) {
        const expandFullScreen = () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          if (device && context) {
            context.configure({
              device: device,
              format: canvasFormat,
              size: { width: canvas.width, height: canvas.height },
            });

            // 深度ステンシルバッファを再作成してサイズを更新
            const depthTexture = device.createTexture({
              size: [canvas.width, canvas.height, 1],
              format: "depth24plus",
              usage: GPUTextureUsage.RENDER_ATTACHMENT,
            });
            depthTextureView = depthTexture.createView();

            updateProjectionMatrix();
          }
        };

        expandFullScreen();
        window.addEventListener("resize", expandFullScreen);
      }

      // リサイズ時に再設定するためのプロジェクションマトリックスを更新
      function updateProjectionMatrix() {
        const fov = degToRad(45);
        const aspect = canvas.width / canvas.height;
        const near = 0.1;
        const far = 1000;
        const projectionMatrix = mat4.perspective(fov, aspect, near, far);

        // 各オブジェクトのユニフォームバッファにプロジェクションマトリックスを再設定
        objects.forEach((object, i) => {
          const uniformBuffer = buffers[i].uniformBuffer;
          const bindGroupSize = buffers[i].bindGroupSize;
          device.queue.writeBuffer(
            uniformBuffer,
            0,
            projectionMatrix.buffer,
            projectionMatrix.byteOffset,
            MAT4_SIZE
          );
        });
      }

      function getObject(alias) {
        return objects.find((object) => object.alias === alias);
      }

      function initControls() {
        const gui = new dat.GUI();

        const settings = {
          SphereColor: [
            getObject("sphere").diffuse[0] * 255,
            getObject("sphere").diffuse[1] * 255,
            getObject("sphere").diffuse[2] * 255,
          ],
          ConeColor: [
            getObject("cone").diffuse[0] * 255,
            getObject("cone").diffuse[1] * 255,
            getObject("cone").diffuse[2] * 255,
          ],
          Shininess: shininess,
          TranslateX: lightPosition[0],
          TranslateY: lightPosition[1],
          TranslateZ: lightPosition[2],
          Distance: distance,
        };

        gui.addColor(settings, "SphereColor").onChange((value) => {
          getObject("sphere").diffuse[0] = value[0] / 255;
          getObject("sphere").diffuse[1] = value[1] / 255;
          getObject("sphere").diffuse[2] = value[2] / 255;
          updateUniforms();
          render();
        });

        gui.addColor(settings, "ConeColor").onChange((value) => {
          getObject("cone").diffuse[0] = value[0] / 255;
          getObject("cone").diffuse[1] = value[1] / 255;
          getObject("cone").diffuse[2] = value[2] / 255;
          updateUniforms();
          render();
        });

        gui.add(settings, "Shininess", 1, 50, 0.1).onChange((value) => {
          shininess = value;
          updateUniforms();
          render();
        });

        gui.add(settings, "TranslateX", -50, 50, 0.1).onChange((value) => {
          lightPosition[0] = value;
          updateUniforms();
          render();
        });

        gui.add(settings, "TranslateY", -50, 50, 0.1).onChange((value) => {
          lightPosition[1] = value;
          updateUniforms();
          render();
        });

        gui.add(settings, "TranslateZ", -50, 50, 0.1).onChange((value) => {
          lightPosition[2] = value;
          updateUniforms();
          render();
        });

        gui.add(settings, "Distance", -200, -50, 0.1).onChange((value) => {
          distance = value;
          updateUniforms();
          render();
        });
      }

      function releaseResources() {
        buffers.forEach(({ vertexBuffer, indexBuffer, uniformBuffer }) => {
          vertexBuffer.destroy();
          indexBuffer.destroy();
          uniformBuffer.destroy();
        });
      }

      window.onload = init;
      window.addEventListener("unload", releaseResources);
    </script>
  </head>
  <body>
    <canvas id="webgpu-canvas">
      Your browser does not support the HTML5 canvas element.
    </canvas>
  </body>
</html>
