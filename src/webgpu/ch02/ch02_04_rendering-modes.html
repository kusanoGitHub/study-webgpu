<!-- 
  WebGL2とWebGPUのレンダリングパイプラインは基本的に異なる設計を持っています。WebGL2では、drawElements や drawArrays などの描画コマンドにより、頂点データの解釈方法を動的に変更できます。これは、特定の描画コマンドが呼び出されるたびに、バインドされている頂点バッファやインデックスバッファが異なる方法で解釈されることを意味します。
一方で、WebGPUではレンダリングパイプラインが作成される際に、プリミティブトポロジーが静的に指定されます。これは、パイプラインが作成された後はトポロジーの種類を変更することができないことを意味しています。したがって、異なるトポロジーを使用してレンダリングを行いたい場合は、それぞれに対応する複数のパイプラインを作成する必要があります。
WebGL2でrenderingModeを変更するだけで異なるプリミティブでの描画が可能なのは、レンダリングの呼び出し時にどのように頂点データを解釈するかを動的に選択できるためです。例えば、gl.drawElements(gl.TRIANGLES, ...)とgl.drawElements(gl.LINE_STRIP, ...)では同じバッファを使用しながら異なる描画結果を得られます。
WebGPUでは、このような動的な変更はサポートされていません。異なるトポロジーで描画するには、各トポロジーに合わせて異なるレンダーパイプラインを作成するか、または頂点データやインデックスデータを変更して新たな描画コマンドを発行する必要があります。これにより、WebGPUはより明示的でパフォーマンス指向のAPIとなっており、開発者は描画の意図をより具体的にGPUに伝える必要があります。
 -->

<html>
  <head>
    <title>Real-Time 3D Graphics with WebGPU</title>
    <link rel="stylesheet" href="../common/lib/normalize.css" />
    <script src="https://cdn.jsdelivr.net/npm/dat.gui"></script>
    <script type="text/javascript" src="../common/js/utils.js"></script>
    <script type="text/javascript">
      "use strict";

      let device,
        context,
        vertexBuffer,
        indexBuffer,
        cellPipeline,
        canvasFormat,
        indices;

      let settings = {
        currentTopology: "triangle-list",
      };

      const TOPOLOGY_CONFIG = {
        "point-list": {
          webGPUTopology: "point-list",
          indices: [1, 2, 3],
          stripIndexFormat: undefined,
        },
        "line-list": {
          webGPUTopology: "line-list",
          indices: [1, 3, 0, 4, 1, 2, 2, 3],
          stripIndexFormat: undefined,
        },
        "line-strip": {
          webGPUTopology: "line-strip",
          indices: [2, 3, 4, 1, 0, 2],
          stripIndexFormat: "uint16",
        },
        "triangle-list": {
          webGPUTopology: "triangle-list",
          indices: [0, 1, 2, 2, 3, 4],
          stripIndexFormat: undefined,
        },
        "triangle-strip": {
          webGPUTopology: "triangle-strip",
          indices: [0, 1, 2, 3, 4],
          stripIndexFormat: "uint16",
        },
        "triangle-fan": {
          webGPUTopology: "triangle-list", // triangle-fanは、WebGPUには存在しないためtriangle-listにマッピング
          indices: [0, 1, 2, 0, 2, 3, 2, 3, 4],
          stripIndexFormat: undefined,
        },
      };

      async function init() {
        const canvas = setupCanvas();
        await setupWebGPU(canvas);
        setupShadersAndPipeline(settings.currentTopology);
        setupBuffers();
        setTopology();
        draw();
        releaseResources();
      }

      function setupCanvas() {
        const canvas = utils.getCanvas("webgpu-canvas");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        return canvas;
      }

      async function setupWebGPU(canvas) {
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        device = await adapter.requestDevice();
        context = utils.getGPUContext(canvas);
        canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: canvasFormat,
        });
      }

      function setupShadersAndPipeline(topology) {
        const cellShaderModule = device.createShaderModule({
          label: "Cell shader",
          code: `@vertex
             fn vertexMain(@location(0) position: vec3<f32>) -> @builtin(position) vec4<f32> {
               return vec4<f32>(position, 1.0);
             }
             @fragment
             fn fragmentMain() -> @location(0) vec4<f32> {
               return vec4<f32>(0.5, 0.5, 1.0, 1.0);
             }`,
        });

        const vertexBufferLayout = {
          arrayStride: 12,
          attributes: [{ format: "float32x3", offset: 0, shaderLocation: 0 }],
        };

        const config = TOPOLOGY_CONFIG[topology];
        const indexFormat = config.stripIndexFormat;

        cellPipeline = device.createRenderPipeline({
          label: "Cell pipeline",
          layout: "auto",
          vertex: {
            module: cellShaderModule,
            entryPoint: "vertexMain",
            buffers: [vertexBufferLayout],
          },
          fragment: {
            module: cellShaderModule,
            entryPoint: "fragmentMain",
            targets: [{ format: canvasFormat }],
          },
          primitive: {
            topology:
              topology === "triangle-fan"
                ? "triangle-list"
                : config.webGPUTopology,
            stripIndexFormat: indexFormat,
          },
        });
      }

      function setupBuffers() {
        const vertices = new Float32Array([
          -0.5, -0.5, 0, -0.25, 0.5, 0, 0.0, -0.5, 0, 0.25, 0.5, 0, 0.5, -0.5,
          0,
        ]);

        vertexBuffer = device.createBuffer({
          label: "Vertex Buffer",
          size: vertices.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(vertexBuffer, 0, vertices);

        const indicesConfig = TOPOLOGY_CONFIG[settings.currentTopology];
        indices = new Uint16Array(indicesConfig.indices);
        const paddedLength = Math.ceil(indices.byteLength / 4) * 4;
        const paddedIndices = new Uint8Array(paddedLength);
        paddedIndices.set(new Uint8Array(indices.buffer));
        indexBuffer = device.createBuffer({
          label: "Index Buffer",
          size: paddedIndices.byteLength,
          usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(indexBuffer, 0, paddedIndices);
      }

      function draw() {
        const commandEncoder = device.createCommandEncoder();
        const pass = commandEncoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              storeOp: "store",
            },
          ],
        });
        pass.setPipeline(cellPipeline);
        pass.setVertexBuffer(0, vertexBuffer);
        pass.setIndexBuffer(indexBuffer, "uint16");
        pass.drawIndexed(indices.length);
        pass.end();
        device.queue.submit([commandEncoder.finish()]);
      }

      function releaseResources() {
        vertexBuffer.destroy();
        indexBuffer.destroy();
      }

      // トポロジー（レンダリングモード）のセットアップ
      function setTopology() {
        const gui = new dat.GUI();
        const topologyNames = Object.keys(TOPOLOGY_CONFIG);
        gui
          .add(settings, "currentTopology", topologyNames)
          // トポロジーを変更する際にシェーダーとバッファーを再設定
          .onChange((topology) => {
            settings.currentTopology = topology; // トポロジーを更新
            setupShadersAndPipeline(settings.currentTopology); // パイプラインを再設定
            setupBuffers(); // バッファーを再設定
            draw(); // 再描画
            releaseResources(); // リソースを解放
          });
      }

      window.onload = init;
    </script>
  </head>
  <body>
    <canvas id="webgpu-canvas">
      Your browser does not support the HTML5 canvas element.
    </canvas>
  </body>
</html>
