<!-- 
  webGL2のコードではdraw関数内にビューポートとプロジェクションマトリックスの更新を行っていましたが、
  webGPUのコードでは構成が異なるのでautoResizeCanvas関数内で更新を行っています。
  ですので、リサイズイベントを取り扱う基本的なアプローチは同じです。
-->

<html>
  <head>
    <title>Real-Time 3D Graphics with WebGPU</title>
    <link rel="stylesheet" href="../common/lib/normalize.css" />
    <script type="text/javascript" src="../common/js/utils.js"></script>
    <script type="text/javascript" src="../common/lib/gl-matrix.js"></script>
    <script type="text/javascript">
      "use strict";

      let canvas,
        device,
        context,
        vertexBuffer,
        indexBuffer,
        cellPipeline,
        uniformBuffer,
        canvasFormat,
        indices,
        projectionMatrix = mat4.create(),
        modelViewMatrix = mat4.create(),
        uniformBindGroup,
        models = [];

      async function init() {
        canvas = setupCanvas();
        await setupWebGPU(canvas);
        setupShadersAndPipeline();
        await loadAllModels("../common/models/nissan-gtr", 179);
        setupUniforms();
        render();
      }

      function setupCanvas() {
        canvas = utils.getCanvas("webgpu-canvas");
        autoResizeCanvas(canvas);
        return canvas;
      }

      async function setupWebGPU(canvas) {
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        device = await adapter.requestDevice();
        context = utils.getGPUContext(canvas);
        canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: canvasFormat,
        });
      }

      function setupShadersAndPipeline() {
        const cellShaderModule = device.createShaderModule({
          label: "Cell shader",
          code: `
                @group(0) @binding(0) var<uniform> uTransform: mat4x4<f32>;

                @vertex
                fn vertexMain(@location(0) position: vec3<f32>) -> @builtin(position) vec4<f32> {
                    return uTransform * vec4<f32>(position, 1.0);
                }

                @fragment
                fn fragmentMain() -> @location(0) vec4<f32> {
                  return vec4<f32>(1.0, 1.0, 1.0, 1.0);
                }`,
        });

        const vertexBufferLayout = {
          arrayStride: 12,
          attributes: [{ format: "float32x3", offset: 0, shaderLocation: 0 }],
        };

        const uniformBindGroupLayout = device.createBindGroupLayout({
          entries: [
            {
              binding: 0,
              visibility: GPUShaderStage.VERTEX,
              buffer: {
                type: "uniform",
              },
            },
          ],
        });

        cellPipeline = device.createRenderPipeline({
          label: "Cell pipeline",
          layout: "auto",
          vertex: {
            module: cellShaderModule,
            entryPoint: "vertexMain",
            buffers: [vertexBufferLayout],
          },
          fragment: {
            module: cellShaderModule,
            entryPoint: "fragmentMain",
            targets: [{ format: canvasFormat }],
          },
          primitive: {
            topology: "line-strip",
            stripIndexFormat: "uint16",
          },
        });
      }

      async function loadAllModels(basePath, count, batchSize = 10) {
        for (let i = 1; i < count; i += batchSize) {
          const batchPromises = [];
          for (let j = i; j < i + batchSize && j < count; j++) {
            const filePath = `${basePath}/part${j}.json`;
            batchPromises.push(load(filePath));
          }
          await Promise.all(batchPromises);
          console.log(`Batch ${i / batchSize + 1} loaded`);
        }
      }

      async function load(filePath) {
        const response = await fetch(filePath);
        const data = await response.json();

        const vertices = new Float32Array(data.vertices);
        vertexBuffer = device.createBuffer({
          label: "Vertex Buffer",
          size: vertices.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(vertexBuffer, 0, vertices);

        indices = new Uint16Array(data.indices);
        const paddedLength = Math.ceil(indices.byteLength / 4) * 4;
        const paddedIndices = new Uint8Array(paddedLength);
        paddedIndices.set(new Uint8Array(indices.buffer));
        indexBuffer = device.createBuffer({
          label: "Index Buffer",
          size: paddedIndices.byteLength,
          usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(indexBuffer, 0, paddedIndices);

        // モデルデータを配列に追加
        models.push({
          vertexBuffer: vertexBuffer,
          indexBuffer: indexBuffer,
          indexCount: indices.length,
        });
      }

      function setupUniforms() {
        // Initialize matrices
        mat4.perspective(
          projectionMatrix,
          Math.PI * 0.25,
          canvas.width / canvas.height,
          10,
          10000
        );
        mat4.identity(modelViewMatrix);
        mat4.translate(modelViewMatrix, modelViewMatrix, [-10, 0, -100]);
        mat4.rotate(
          modelViewMatrix,
          modelViewMatrix,
          (30 * Math.PI) / 180,
          [1, 0, 0]
        );
        mat4.rotate(
          modelViewMatrix,
          modelViewMatrix,
          (30 * Math.PI) / 180,
          [0, 1, 0]
        );

        // Combine the matrices
        const combinedMatrix = mat4.create();
        mat4.multiply(combinedMatrix, projectionMatrix, modelViewMatrix);

        // Create uniform buffer
        uniformBuffer = device.createBuffer({
          size: combinedMatrix.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(uniformBuffer, 0, combinedMatrix);

        // Create bind group
        uniformBindGroup = device.createBindGroup({
          layout: cellPipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: uniformBuffer,
              },
            },
          ],
        });
      }

      function draw() {
        const commandEncoder = device.createCommandEncoder();
        const pass = commandEncoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: { r: 0, g: 0, b: 0, a: 1 },
              storeOp: "store",
            },
          ],
        });
        pass.setPipeline(cellPipeline);
        models.forEach((model) => {
          pass.setVertexBuffer(0, model.vertexBuffer);
          pass.setIndexBuffer(model.indexBuffer, "uint16");
          pass.setBindGroup(0, uniformBindGroup);
          pass.drawIndexed(model.indexCount);
        });
        pass.end();
        device.queue.submit([commandEncoder.finish()]);
      }

      function releaseResources() {
        vertexBuffer.destroy();
        indexBuffer.destroy();
        uniformBuffer.destroy();
      }

      /*
       * requestAnimationFrameを用いて、パフォーマンスの向上と応答性の向上を実現します。
       * パフォーマンス: 不要な再描画を避けながら、必要な時にのみ描画処理が行われます。
       * 応答性: ユーザーの画面サイズ変更に迅速に反応し、画面のちらつきを減少させます。
       */
      function render() {
        draw(); // フレームごとにシーンを再描画
        requestAnimationFrame(render); // 次のフレームをスケジュール
      }

      function autoResizeCanvas(canvas) {
        const expandFullScreen = () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          if (device && context) {
            // ビューポートの更新
            context.configure({
              device: device,
              format: canvasFormat,
              size: { width: canvas.width, height: canvas.height },
            });
            setupUniforms(); // プロジェクションマトリックスを更新
          }
        };

        expandFullScreen();
        window.addEventListener("resize", expandFullScreen);
      }

      window.onload = init;
      window.addEventListener("unload", releaseResources);
    </script>
  </head>
  <body>
    <canvas id="webgpu-canvas">
      Your browser does not support the HTML5 canvas element.
    </canvas>
  </body>
</html>
