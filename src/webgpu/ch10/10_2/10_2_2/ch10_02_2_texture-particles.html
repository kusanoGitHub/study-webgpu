<!-- 
  webGL2ではポイントスプライトで実装していたが、
  webGPUではポイントスプライトではなく、各パーティクルを四角形の頂点として扱い、
  その上にテクスチャを貼り付けています。
-->
<html>
  <head>
    <title>Real-Time 3D Graphics with WebGPU</title>
    <link rel="stylesheet" href="../../../common/lib/normalize.css" />
    <script type="text/javascript" src="../../../common/js/utils.js"></script>
    <script
      type="text/javascript"
      src="../../../common/lib/dat.gui.js"
    ></script>
    <script
      type="text/javascript"
      src="../../../common/js/EventEmitter.js"
    ></script>
    <script type="text/javascript" src="../../../common/js/Clock.js"></script>
    <script
      type="text/javascript"
      src="../../../common/js/Controls.js"
    ></script>
    <script type="module" src="../../../common/js/Camera.js"></script>
    <script type="module">
      ("use strict");
      import {
        vec3,
        vec4,
        mat4,
      } from "https://wgpu-matrix.org/dist/1.x/wgpu-matrix.module.js";
      import Camera from "../../../common/js/Camera.js";

      const FLOAT_SIZE = 4,
        MAT4_SIZE = 16 * FLOAT_SIZE,
        VEC3_SIZE = 3 * FLOAT_SIZE,
        VEC4_SIZE = 4 * FLOAT_SIZE,
        VEC3_PADDING = 4,
        degToRad = (d) => (d * Math.PI) / 180;

      let canvas,
        device,
        context,
        canvasFormat,
        camera,
        particlePipeline,
        texture,
        sampler,
        objects = [],
        buffers = {},
        depthTextureView,
        particleArray,
        particleBuffer,
        particles = [],
        lastFrameTime = Date.now(),
        particleSize = 0.3,
        particleLifeSpan = 3;

      async function init() {
        canvas = setupCanvas();
        await setupWebGPU(canvas);
        setupCamera();
        await loadTexture();
        await loadParticles(1024);
        await setupShadersAndPipeline();
        setupBuffers();
        render();
        initControls();
      }

      function setupCanvas() {
        canvas = utils.getCanvas("webgpu-canvas");
        autoResizeCanvas(canvas);
        return canvas;
      }

      async function setupWebGPU(canvas) {
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        device = await adapter.requestDevice();
        context = utils.getGPUContext(canvas);
        canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: canvasFormat,
        });
      }

      function setupCamera() {
        camera = new Camera(Camera.ORBITING_TYPE);
        camera.goHome([0, 0, 50]);
        camera.setFocus([0, 0, 0]);
        camera.setAzimuth(-40);
        camera.setElevation(-30);
        new Controls(camera, canvas);
      }

      async function setupShadersAndPipeline() {
        const vertexShaderModule = device.createShaderModule({
          code: await fetch("./vertexShader.wgsl").then((res) => res.text()),
        });

        const fragmentShaderModule = device.createShaderModule({
          code: await fetch("./fragmentShader.wgsl").then((res) => res.text()),
        });

        const vertexBufferLayout = {
          arrayStride: 5 * Float32Array.BYTES_PER_ELEMENT,
          stepMode: "instance",
          attributes: [
            // partice position
            {
              format: "float32x4",
              offset: 0,
              shaderLocation: 0,
            },
            // size
            {
              format: "float32",
              offset: 4 * Float32Array.BYTES_PER_ELEMENT,
              shaderLocation: 1,
            },
          ],
        };

        const uniformBindGroupLayout = device.createBindGroupLayout({
          entries: [
            {
              binding: 0,
              visibility: GPUShaderStage.VERTEX,
              buffer: {
                type: "uniform",
              },
            },
            { binding: 1, visibility: GPUShaderStage.FRAGMENT, sampler: {} },
            {
              binding: 2,
              visibility: GPUShaderStage.FRAGMENT,
              texture: { sampleType: "float" },
            },
          ],
        });

        particlePipeline = device.createRenderPipeline({
          label: "particles pipeline",
          layout: device.createPipelineLayout({
            bindGroupLayouts: [uniformBindGroupLayout],
          }),
          vertex: {
            module: vertexShaderModule,
            entryPoint: "vertexMain",
            buffers: [vertexBufferLayout],
          },
          fragment: {
            module: fragmentShaderModule,
            entryPoint: "fragmentMain",
            targets: [
              {
                format: canvasFormat,
                blend: {
                  color: {
                    srcFactor: "src-alpha",
                    dstFactor: "one",
                    operation: "add",
                  },
                  alpha: {
                    srcFactor: "src-alpha",
                    dstFactor: "one",
                    operation: "add",
                  },
                },
              },
            ],
          },
          primitive: {
            topology: "triangle-list",
            cullMode: "none",
          },
          depthStencil: {
            format: "depth24plus",
            depthWriteEnabled: false, // 深度があるとテクスチャ画像の背景が透明にならないので無効にする
            depthCompare: "less",
          },
        });
      }

      async function loadTexture() {
        const img = new Image();
        img.src = "../../../common/images/spark.png";
        await img.decode();

        const imageBitmap = await createImageBitmap(img);

        texture = device.createTexture({
          size: [img.width, img.height, 1],
          format: "rgba8unorm",
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_DST |
            GPUTextureUsage.RENDER_ATTACHMENT,
        });

        device.queue.copyExternalImageToTexture(
          { source: imageBitmap },
          { texture: texture },
          [img.width, img.height, 1]
        );

        sampler = device.createSampler({
          magFilter: "linear",
          minFilter: "linear",
        });
      }

      function loadParticles(count) {
        particleArray = new Float32Array(count * 5);
        for (let i = 0; i < count; ++i) {
          const particle = {};
          resetParticle(particle);
          particles.push(particle);

          const index = i * 5;
          particleArray[index] = particle.position[0];
          particleArray[index + 1] = particle.position[1];
          particleArray[index + 2] = particle.position[2];
          particleArray[index + 3] = particle.remainingLife / particle.lifeSpan;
          particleArray[index + 4] = particleSize;
        }
      }

      function resetParticle(particle) {
        particle.position = [0, 0, 0];
        particle.velocity = [
          Math.random() * 20 - 10,
          Math.random() * 20,
          Math.random() * 20 - 10,
        ];
        particle.lifeSpan = Math.random() * particleLifeSpan;
        particle.remainingLife = particle.lifeSpan;
      }

      function setupBuffers() {
        const fov = degToRad(45);
        const aspect = canvas.width / canvas.height;
        const near = camera.minZ;
        const far = camera.maxZ;
        const projectionMatrix = mat4.perspective(fov, aspect, near, far);

        const SUM_MAT4_SIZE = 2 * MAT4_SIZE;

        const alignedSize = SUM_MAT4_SIZE;

        const modelViewMatrix = camera.getViewTransform();

        const uniformData = new Float32Array(alignedSize / FLOAT_SIZE);
        let offset = 0;

        uniformData.set(projectionMatrix, offset);
        offset += MAT4_SIZE / FLOAT_SIZE;

        uniformData.set(modelViewMatrix, offset);

        const uniformBuffer = device.createBuffer({
          label: "Uniform Buffer",
          size: uniformData.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(uniformBuffer, 0, uniformData);

        const uniformBindGroup = device.createBindGroup({
          label: "Uniform Bind Group",
          layout: particlePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: uniformBuffer,
                size: uniformData.byteLength,
              },
            },
            { binding: 1, resource: sampler },
            { binding: 2, resource: texture.createView() },
          ],
        });

        particleBuffer = device.createBuffer({
          size: particleArray.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(particleBuffer, 0, particleArray);

        buffers = {
          vertexBuffer: particleBuffer,
          uniformBindGroup: uniformBindGroup,
          uniformBuffer: uniformBuffer,
          bindGroupSize: uniformData.byteLength,
        };

        const depthTexture = device.createTexture({
          size: [canvas.width, canvas.height, 1],
          format: "depth24plus",
          usage: GPUTextureUsage.RENDER_ATTACHMENT,
        });
        depthTextureView = depthTexture.createView();
      }

      function updateBuffers(elapsed) {
        const SUM_MAT4_SIZE = 1 * MAT4_SIZE;

        const alignedSize = SUM_MAT4_SIZE;

        const modelViewMatrix = camera.getViewTransform();

        const uniformData = new Float32Array(alignedSize / FLOAT_SIZE);
        let offset = 0;

        uniformData.set(modelViewMatrix, offset);

        const uniformBuffer = buffers.uniformBuffer;
        const bindGroupSize = buffers.bindGroupSize;

        device.queue.writeBuffer(
          uniformBuffer,
          MAT4_SIZE,
          uniformData.buffer,
          uniformData.byteOffset,
          alignedSize
        );

        const uniformBindGroup = device.createBindGroup({
          label: "Update Uniform Bind Group",
          layout: particlePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: uniformBuffer,
                size: bindGroupSize,
              },
            },
            { binding: 1, resource: sampler },
            { binding: 2, resource: texture.createView() },
          ],
        });

        buffers.uniformBindGroup = uniformBindGroup;

        // パーティクルを更新
        particles.forEach((particle, i) => {
          particle.remainingLife -= elapsed;

          if (particle.remainingLife <= 0) {
            resetParticle(particle);
          }

          particle.position[0] += particle.velocity[0] * elapsed;
          particle.position[1] += particle.velocity[1] * elapsed;
          particle.position[2] += particle.velocity[2] * elapsed;

          particle.velocity[1] -= 9.8 * elapsed;

          if (particle.position[1] < 0) {
            particle.velocity[1] *= -0.75;
            particle.position[1] = 0;
          }

          const index = i * 5;
          particleArray[index] = particle.position[0];
          particleArray[index + 1] = particle.position[1];
          particleArray[index + 2] = particle.position[2];
          particleArray[index + 3] = particle.remainingLife / particle.lifeSpan;
          particleArray[index + 4] = particleSize;
        });

        device.queue.writeBuffer(
          buffers.vertexBuffer,
          0,
          particleArray.buffer,
          particleArray.byteOffset,
          particleArray.byteLength
        );
      }

      async function draw() {
        const commandEncoder = device.createCommandEncoder();
        const pass = commandEncoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              loadOp: "clear",
              clearValue: [0.1, 0.1, 0.1, 1.0],
              storeOp: "store",
            },
          ],
          depthStencilAttachment: {
            view: depthTextureView,
            depthClearValue: 1.0,
            depthLoadOp: "clear",
            depthStoreOp: "store",
          },
        });

        pass.setPipeline(particlePipeline);
        pass.setBindGroup(0, buffers.uniformBindGroup);
        pass.setVertexBuffer(0, buffers.vertexBuffer);
        pass.draw(6, particles.length);

        pass.end();
        device.queue.submit([commandEncoder.finish()]);
      }
      function render() {
        requestAnimationFrame(render);
        draw();
        const now = Date.now();
        const elapsed = (now - lastFrameTime) / 1000.0;
        updateBuffers(elapsed);
        lastFrameTime = now;
      }

      function autoResizeCanvas(canvas) {
        const expandFullScreen = () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          if (device && context) {
            context.configure({
              device: device,
              format: canvasFormat,
              size: { width: canvas.width, height: canvas.height },
            });

            const depthTexture = device.createTexture({
              size: [canvas.width, canvas.height, 1],
              format: "depth24plus",
              usage: GPUTextureUsage.RENDER_ATTACHMENT,
            });
            depthTextureView = depthTexture.createView();

            updateProjectionMatrix();
          }
        };

        expandFullScreen();
        window.addEventListener("resize", expandFullScreen);
      }

      function updateProjectionMatrix() {
        const fov = degToRad(45);
        const aspect = canvas.width / canvas.height;
        const near = 0.1;
        const far = 10000;
        const projectionMatrix = mat4.perspective(fov, aspect, near, far);

        const uniformBuffer = buffers.uniformBuffer;
        device.queue.writeBuffer(
          uniformBuffer,
          0,
          projectionMatrix.buffer,
          projectionMatrix.byteOffset,
          MAT4_SIZE
        );
      }

      function initControls() {
        utils.configureControls({
          "Particle Size": {
            value: particleSize,
            min: 0.1,
            max: 1,
            step: 0.1,
            onChange: (v) => (particleSize = v),
          },
          "Particle Life Span": {
            value: particleLifeSpan,
            min: 1,
            max: 10,
            step: 0.1,
            onChange: (v) => (particleLifeSpan = v),
          },
        });
      }

      window.onload = init;
      window.addEventListener("unload", utils.releaseResources(buffers));
    </script>
  </head>
  <body>
    <canvas id="webgpu-canvas">
      Your browser does not support the HTML5 canvas element.
    </canvas>
  </body>
</html>
