<html>
  <head>
    <title>Real-Time 3D Graphics with WebGPU</title>
    <link rel="stylesheet" href="../../common/lib/normalize.css" />
    <script type="text/javascript" src="../../common/js/utils.js"></script>
    <script type="text/javascript" src="../../common/lib/dat.gui.js"></script>
    <script
      type="text/javascript"
      src="../../common/js/EventEmitter.js"
    ></script>
    <script type="text/javascript" src="../../common/js/Clock.js"></script>
    <script type="text/javascript" src="../../common/js/Controls.js"></script>
    <script type="module" src="../../common/js/Camera.js"></script>
    <script type="module">
      ("use strict");
      import {
        vec3,
        vec4,
        mat4,
      } from "https://wgpu-matrix.org/dist/1.x/wgpu-matrix.module.js";
      import Camera from "../../common/js/Camera.js";

      const FLOAT_SIZE = 4,
        MAT4_SIZE = 16 * FLOAT_SIZE,
        VEC3_SIZE = 3 * FLOAT_SIZE,
        VEC4_SIZE = 4 * FLOAT_SIZE,
        VEC3_PADDING = 4,
        degToRad = (d) => (d * Math.PI) / 180;

      let canvas,
        device,
        context,
        canvasFormat,
        camera,
        trianglePipeline,
        buffers = [],
        startTime = Date.now(),
        time = 0;

      async function init() {
        canvas = setupCanvas();
        await setupWebGPU(canvas);
        setupCamera();
        await setupShadersAndPipeline();
        render();
      }

      function setupCanvas() {
        canvas = utils.getCanvas("webgpu-canvas");
        autoResizeCanvas(canvas);
        return canvas;
      }

      async function setupWebGPU(canvas) {
        if (!navigator.gpu) {
          throw new Error("WebGPU not supported on this browser.");
        }
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("No appropriate GPUAdapter found.");
        }
        device = await adapter.requestDevice();
        context = utils.getGPUContext(canvas);
        canvasFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
          device: device,
          format: canvasFormat,
        });
      }

      function setupCamera() {
        camera = new Camera(Camera.ORBITING_TYPE);
        camera.goHome([0, 0, 140]);
        camera.setFocus([0, 0, 0]);
        camera.setAzimuth(-40);
        camera.setElevation(-30);
        new Controls(camera, canvas);
      }

      async function setupShadersAndPipeline() {
        const vertexShaderModule = device.createShaderModule({
          code: await fetch("./vertexShader.wgsl").then((res) => res.text()),
        });

        const fragmentShaderModule = device.createShaderModule({
          code: await fetch("./fragmentShader.wgsl").then((res) => res.text()),
        });

        const vertexBufferLayout = {
          arrayStride: 2 * Float32Array.BYTES_PER_ELEMENT,
          attributes: [
            // position
            {
              format: "float32x2",
              offset: 0,
              shaderLocation: 0,
            },
          ],
        };

        const uniformBindGroupLayout = device.createBindGroupLayout({
          entries: [
            {
              binding: 0,
              visibility: GPUShaderStage.FRAGMENT,
              buffer: {
                type: "uniform",
              },
            },
          ],
        });

        trianglePipeline = device.createRenderPipeline({
          label: "Triangle pipeline",
          layout: device.createPipelineLayout({
            bindGroupLayouts: [uniformBindGroupLayout],
          }),
          vertex: {
            module: vertexShaderModule,
            entryPoint: "vertexMain",
            buffers: [vertexBufferLayout],
          },
          fragment: {
            module: fragmentShaderModule,
            entryPoint: "fragmentMain",
            targets: [
              {
                format: canvasFormat,
              },
            ],
          },
          primitive: {
            topology: "triangle-list",
          },
        });
      }

      async function draw() {
        const commandEncoder = device.createCommandEncoder();

        const SUM_FLORT32_SIZE = 3 * FLOAT_SIZE + 4; // 4: padding
        const alignedSize = SUM_FLORT32_SIZE;
        const uniformData = new Float32Array(alignedSize / FLOAT_SIZE);
        let offset = 0;

        uniformData.set([time], offset);
        offset += 1;

        uniformData.set([1 / canvas.width], offset);
        offset += 1;

        uniformData.set([1 / canvas.height], offset);

        const uniformBuffer = device.createBuffer({
          label: "Uniform Buffer",
          size: uniformData.byteLength,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(uniformBuffer, 0, uniformData);

        const uniformBindGroup = device.createBindGroup({
          layout: trianglePipeline.getBindGroupLayout(0),
          entries: [
            {
              binding: 0,
              resource: {
                buffer: uniformBuffer,
                size: uniformData.byteLength,
              },
            },
          ],
        });

        const postPass = commandEncoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              loadOp: "clear",
              storeOp: "store",
              clearValue: [0, 0, 0, 1],
            },
          ],
        });

        postPass.setPipeline(trianglePipeline);
        postPass.setBindGroup(0, uniformBindGroup);

        const postVertices = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        const postVertexData = [];

        for (let i = 0; i < postVertices.length / 2; i++) {
          const vertexIndex = i * 2;

          postVertexData.push(
            // position
            postVertices[vertexIndex],
            postVertices[vertexIndex + 1]
          );
        }

        const postVertexDataFloat32Array = new Float32Array(postVertexData);

        const vertexBuffer = device.createBuffer({
          label: "Post Vertex Buffer",
          size: postVertexDataFloat32Array.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
        });
        device.queue.writeBuffer(vertexBuffer, 0, postVertexDataFloat32Array);

        postPass.setVertexBuffer(0, vertexBuffer);
        postPass.draw(6); // 四角形を描画
        postPass.end();

        device.queue.submit([commandEncoder.finish()]);
      }

      function render() {
        requestAnimationFrame(render);
        time = (Date.now() - startTime) / 1000;
        draw();
      }

      function autoResizeCanvas(canvas) {
        const expandFullScreen = () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
          if (device && context) {
            context.configure({
              device: device,
              format: canvasFormat,
              size: { width: canvas.width, height: canvas.height },
            });

            updateProjectionMatrix();
          }
        };

        expandFullScreen();
        window.addEventListener("resize", expandFullScreen);
      }

      window.onload = init;
      window.addEventListener("unload", utils.releaseResources(buffers));
    </script>
  </head>
  <body>
    <canvas id="webgpu-canvas">
      Your browser does not support the HTML5 canvas element.
    </canvas>
  </body>
</html>
